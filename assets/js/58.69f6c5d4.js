(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{398:function(t,e,s){"use strict";s.r(e);var n=s(43),p=Object(n.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("extends [aiksdens]")]),t._v(" "),s("p",[t._v("Class 通过extends关键字实现继承，\n比ES5通过修改原型链实现继承，要清洗和方便的多。"),s("a",{attrs:{href:""}},[t._v("ES5与ES6的继承比较")])]),t._v(" "),s("p",[t._v("继承中出现的"),s("code",[t._v("super")]),t._v("关键字，它在这里表示父类的构造函数，用来新建父类的this对象。")]),t._v(" "),s("p",[s("code",[t._v("object.getPrototypeOf(子类) === 父类")]),t._v("通过此方法可以判断一个类是否继承了另一个类")]),t._v(" "),s("p",[t._v("React 高阶组件是否可以继承父类的静态属性？？？")]),t._v(" "),s("p",[t._v("ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。\nES6的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this")])])},[],!1,null,null,null);e.default=p.exports}}]);